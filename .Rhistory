if(length(col) == 1){
if(col == "white"){
fill <- c("white","white","white")
} else {
pal <- colorRampPalette(c("white",col,"black"))(11)
fill <- c(col, pal[3],pal[7])
}
}
if(length(col)==2){
fill <- c(col[1],col[2],col[2])
}
if(length(col)==3){
fill <- col
}
faces$fill <- fill[2]
faces[faces$ang > 0,"fill"] <- fill[3]
# Tops
tops <- x
for (i in 1:dim(tops)[1])
{
st_geometry(tops[i,]) <- st_geometry(tops[i,]) + c(0, as.numeric(x[i,var])[1] * k)
}
tops <- tops[order(tops$height, decreasing = FALSE),]
# faces <- st_difference(faces,st_buffer(st_union(st_geometry(tops)),1))
# plot(st_geometry(faces), col="red")
# Opérations géométriques
# 1 - Faces cleaning
if(regular == FALSE){
message("Topological issues (1/3)")
faces$xpos <- round(st_coordinates(st_centroid(st_geometry(faces)))[,1],0)
faces$dup1 <- as.numeric(duplicated(faces$pos))
faces$dup2 <- as.numeric(duplicated(faces$pos, fromLast = TRUE))
faces$dup3 <- as.numeric(duplicated(faces$xpos))
faces$dup4 <- as.numeric(duplicated(faces$xpos, fromLast = TRUE))
faces$test1 <- faces$dup1 + faces$dup3
faces$test2 <- faces$dup2 + faces$dup4
faces$test3 <- faces$dup1 + faces$dup2 + faces$dup3 + faces$dup4
f1 <- faces[faces$test1 == 2,]
f2 <- faces[faces$test2 == 2,]
f3 <- faces[faces$test3 == 0,]
nb <- dim(f2)[1]
f <- f1
for(i in 1:nb){
if (f1$height[i] == max(f1$heigh[i],f2$heigh[i])){
st_geometry(f[i,]) <- st_difference(st_geometry(f1[i,]),st_geometry(f2[i,]) )
f$id[i] <- f1$id[i]
} else {
st_geometry(f[i,]) <- st_difference(st_geometry(f2[i,]),st_geometry(f1[i,]) )
f$id[i] <- f2$id[i]
}
}
faces <- f
faces <- faces[order(faces$pos, decreasing = TRUE),]
# alltops <- st_buffer(st_union(st_geometry(tops)),1)
# faces <- st_difference(faces,alltops)
# 2 -Tops cleaning
message("Topological issues (2/3)")
blocs <- x
for (i in ids){
#st_geometry(blocs[i,]) <- st_buffer(st_union(st_union(st_geometry(faces[faces$id==i,]),st_geometry(tops[tops$id==i,]))),1)
st_geometry(blocs[i,]) <- st_buffer(st_union(st_union(st_geometry(faces[faces$id==i,]),st_geometry(tops[tops$id==i,]))),1)
}
message("Topological issues (3/3)")
for(i in ids){
v <- as.numeric(tops[tops$id == i,var] %>% st_drop_geometry())
tmp <- tops %>% st_drop_geometry()
ids2 <- tmp[tmp[,var] > v & tmp$id != i,"id"]
geom1 <- st_geometry(tops[tops$id == i,])
# plot(geom1)
geom2 <- st_geometry(blocs[blocs$id %in% ids2,])
# plot(geom2)
geom <- st_difference(geom1, st_union(geom2))
if(length(geom) > 0) {
st_geometry(tops[tops$id == i,]) <- geom
} else {
# Supprimer les geometries vides (TODO)
}
}
# 3  - bind & sort faces
# faces2 <- st_difference(f3,st_buffer(st_union(st_geometry(tops)),1))
f <- rbind(faces, f3)
f <- f[order(f$pos, decreasing = TRUE),]
} else {f <- faces}
# Display
#
#
# plot(st_geometry(x), add=add)
# plot(st_geometry(f), col = f$fill, add=T)
# plot(st_geometry(tops), col=fill[1], add=T)
for(i in tops$id)
{
plot(st_geometry(f[f$id == i,]), col="red", add=T)
plot(st_geometry(tops[tops$id == i,]), col="yellow", add=T)
}
message("Done")
}
states <- readRDS("us.rds")
basemap <- deform(states)
extrude(basemap, var = "pop2019" , k = 1, col = "red", add = FALSE)
extrude <- function(x, var, k = 1, col = "red", regular = FALSE, add = FALSE) {
tmp <- x[is.na(x[,var]),]
ids <- row.names(tmp)
x[rownames(x) %in% ids,var] <- 0
h <- st_bbox(x)[4]-st_bbox(x)[2]
m <- max(x[,var] %>% st_drop_geometry())
k = k * 0.1 * h / m
x$id <- row.names(x)
x[,"height"] <- x[,var] %>% st_drop_geometry() * k
x[is.na(x[,var]),"height"] <- 0
n1 <- dim(x)[1]
x <- st_cast(x, "POLYGON", warn = FALSE)
n2 <- dim(x)[1]
if(n2 > n1){message("Splitting multi-part polygon into single polygons. The same value is assigned to each splitted polygon.")}
nodes <- st_cast(x,"POINT", warn = FALSE)
# Faces
message("Starting extrusion")
nodes$first <- !duplicated(nodes$id)
nodes$last <- !duplicated(nodes$id, fromLast = TRUE)
dots1 <- nodes[!nodes$last,]
dots2 <- nodes[!nodes$first,]
p1x <- st_coordinates(dots1)[,1]
p1y <- st_coordinates(dots1)[,2]
p2x <- st_coordinates(dots2)[,1]
p2y <- st_coordinates(dots2)[,2]
p3x <- p2x
p3y <- p2y + dots2$height
p4x <- p1x
p4y <- p1y + dots1$height
faces <- dots1
faces$ang <- atan((p2y - p1y) / ( p2x - p1x))*180/pi
faces$pos <- (p1y + p2y)/2
st_geometry(faces) <- st_as_sfc(paste0("POLYGON((",p1x," ",p1y,", ",p2x," ",p2y,", ",p3x," ",p3y,", ",p4x," ",p4y,", ",p1x," ",p1y,"))"))
faces <- faces[order(faces$pos, decreasing = TRUE),]
# Colors
if(length(col) == 1){
if(col == "white"){
fill <- c("white","white","white")
} else {
pal <- colorRampPalette(c("white",col,"black"))(11)
fill <- c(col, pal[3],pal[7])
}
}
if(length(col)==2){
fill <- c(col[1],col[2],col[2])
}
if(length(col)==3){
fill <- col
}
faces$fill <- fill[2]
faces[faces$ang > 0,"fill"] <- fill[3]
# Tops
tops <- x
for (i in 1:dim(tops)[1])
{
st_geometry(tops[i,]) <- st_geometry(tops[i,]) + c(0, as.numeric(x[i,var])[1] * k)
}
tops <- tops[order(tops$height, decreasing = FALSE),]
# faces <- st_difference(faces,st_buffer(st_union(st_geometry(tops)),1))
# plot(st_geometry(faces), col="red")
# Opérations géométriques
# 1 - Faces cleaning
if(regular == FALSE){
message("Topological issues (1/3)")
faces$xpos <- round(st_coordinates(st_centroid(st_geometry(faces)))[,1],0)
faces$dup1 <- as.numeric(duplicated(faces$pos))
faces$dup2 <- as.numeric(duplicated(faces$pos, fromLast = TRUE))
faces$dup3 <- as.numeric(duplicated(faces$xpos))
faces$dup4 <- as.numeric(duplicated(faces$xpos, fromLast = TRUE))
faces$test1 <- faces$dup1 + faces$dup3
faces$test2 <- faces$dup2 + faces$dup4
faces$test3 <- faces$dup1 + faces$dup2 + faces$dup3 + faces$dup4
f1 <- faces[faces$test1 == 2,]
f2 <- faces[faces$test2 == 2,]
f3 <- faces[faces$test3 == 0,]
nb <- dim(f2)[1]
f <- f1
for(i in 1:nb){
if (f1$height[i] == max(f1$heigh[i],f2$heigh[i])){
st_geometry(f[i,]) <- st_difference(st_geometry(f1[i,]),st_geometry(f2[i,]) )
f$id[i] <- f1$id[i]
} else {
st_geometry(f[i,]) <- st_difference(st_geometry(f2[i,]),st_geometry(f1[i,]) )
f$id[i] <- f2$id[i]
}
}
faces <- f
faces <- faces[order(faces$pos, decreasing = TRUE),]
# alltops <- st_buffer(st_union(st_geometry(tops)),1)
# faces <- st_difference(faces,alltops)
# 2 -Tops cleaning
message("Topological issues (2/3)")
blocs <- x
for (i in ids){
#st_geometry(blocs[i,]) <- st_buffer(st_union(st_union(st_geometry(faces[faces$id==i,]),st_geometry(tops[tops$id==i,]))),1)
st_geometry(blocs[i,]) <- st_buffer(st_union(st_union(st_geometry(faces[faces$id==i,]),st_geometry(tops[tops$id==i,]))),1)
}
message("Topological issues (3/3)")
for(i in ids){
v <- as.numeric(tops[tops$id == i,var] %>% st_drop_geometry())
tmp <- tops %>% st_drop_geometry()
ids2 <- tmp[tmp[,var] > v & tmp$id != i,"id"]
geom1 <- st_geometry(tops[tops$id == i,])
# plot(geom1)
geom2 <- st_geometry(blocs[blocs$id %in% ids2,])
# plot(geom2)
geom <- st_difference(geom1, st_union(geom2))
if(length(geom) > 0) {
st_geometry(tops[tops$id == i,]) <- geom
} else {
# Supprimer les geometries vides (TODO)
}
}
# 3  - bind & sort faces
# faces2 <- st_difference(f3,st_buffer(st_union(st_geometry(tops)),1))
f <- rbind(faces, f3)
f <- f[order(f$pos, decreasing = TRUE),]
} else {f <- faces}
# Display
#
#
# plot(st_geometry(x), add=add)
# plot(st_geometry(f), col = f$fill, add=T)
# plot(st_geometry(tops), col=fill[1], add=T)
plot(st_geometry(x), add=add)
for(i in tops$id)
{
plot(st_geometry(f[f$id == i,]), col="red", add=T)
plot(st_geometry(tops[tops$id == i,]), col="yellow", add=T)
}
message("Done")
}
states <- readRDS("us.rds")
basemap <- deform(states)
extrude(basemap, var = "pop2019" , k = 1, col = "red", add = FALSE)
extrude <- function(x, var, k = 1, col = "red", regular = FALSE, add = FALSE) {
tmp <- x[is.na(x[,var]),]
ids <- row.names(tmp)
x[rownames(x) %in% ids,var] <- 0
h <- st_bbox(x)[4]-st_bbox(x)[2]
m <- max(x[,var] %>% st_drop_geometry())
k = k * 0.1 * h / m
x$id <- row.names(x)
x[,"height"] <- x[,var] %>% st_drop_geometry() * k
x[is.na(x[,var]),"height"] <- 0
n1 <- dim(x)[1]
x <- st_cast(x, "POLYGON", warn = FALSE)
n2 <- dim(x)[1]
if(n2 > n1){message("Splitting multi-part polygon into single polygons. The same value is assigned to each splitted polygon.")}
nodes <- st_cast(x,"POINT", warn = FALSE)
# Faces
message("Starting extrusion")
nodes$first <- !duplicated(nodes$id)
nodes$last <- !duplicated(nodes$id, fromLast = TRUE)
dots1 <- nodes[!nodes$last,]
dots2 <- nodes[!nodes$first,]
p1x <- st_coordinates(dots1)[,1]
p1y <- st_coordinates(dots1)[,2]
p2x <- st_coordinates(dots2)[,1]
p2y <- st_coordinates(dots2)[,2]
p3x <- p2x
p3y <- p2y + dots2$height
p4x <- p1x
p4y <- p1y + dots1$height
faces <- dots1
faces$ang <- atan((p2y - p1y) / ( p2x - p1x))*180/pi
faces$pos <- (p1y + p2y)/2
st_geometry(faces) <- st_as_sfc(paste0("POLYGON((",p1x," ",p1y,", ",p2x," ",p2y,", ",p3x," ",p3y,", ",p4x," ",p4y,", ",p1x," ",p1y,"))"))
faces <- faces[order(faces$pos, decreasing = TRUE),]
# Colors
if(length(col) == 1){
if(col == "white"){
fill <- c("white","white","white")
} else {
pal <- colorRampPalette(c("white",col,"black"))(11)
fill <- c(col, pal[3],pal[7])
}
}
if(length(col)==2){
fill <- c(col[1],col[2],col[2])
}
if(length(col)==3){
fill <- col
}
faces$fill <- fill[2]
faces[faces$ang > 0,"fill"] <- fill[3]
# Tops
tops <- x
for (i in 1:dim(tops)[1])
{
st_geometry(tops[i,]) <- st_geometry(tops[i,]) + c(0, as.numeric(x[i,var])[1] * k)
}
tops <- tops[order(tops$height, decreasing = FALSE),]
# faces <- st_difference(faces,st_buffer(st_union(st_geometry(tops)),1))
# plot(st_geometry(faces), col="red")
# Opérations géométriques
# 1 - Faces cleaning
if(regular == FALSE){
message("Topological issues (1/3)")
faces$xpos <- round(st_coordinates(st_centroid(st_geometry(faces)))[,1],0)
faces$dup1 <- as.numeric(duplicated(faces$pos))
faces$dup2 <- as.numeric(duplicated(faces$pos, fromLast = TRUE))
faces$dup3 <- as.numeric(duplicated(faces$xpos))
faces$dup4 <- as.numeric(duplicated(faces$xpos, fromLast = TRUE))
faces$test1 <- faces$dup1 + faces$dup3
faces$test2 <- faces$dup2 + faces$dup4
faces$test3 <- faces$dup1 + faces$dup2 + faces$dup3 + faces$dup4
f1 <- faces[faces$test1 == 2,]
f2 <- faces[faces$test2 == 2,]
f3 <- faces[faces$test3 == 0,]
nb <- dim(f2)[1]
f <- f1
for(i in 1:nb){
if (f1$height[i] == max(f1$heigh[i],f2$heigh[i])){
st_geometry(f[i,]) <- st_difference(st_geometry(f1[i,]),st_geometry(f2[i,]) )
f$id[i] <- f1$id[i]
} else {
st_geometry(f[i,]) <- st_difference(st_geometry(f2[i,]),st_geometry(f1[i,]) )
f$id[i] <- f2$id[i]
}
}
faces <- f
faces <- faces[order(faces$pos, decreasing = TRUE),]
# alltops <- st_buffer(st_union(st_geometry(tops)),1)
# faces <- st_difference(faces,alltops)
# 2 -Tops cleaning
message("Topological issues (2/3)")
blocs <- x
for (i in ids){
#st_geometry(blocs[i,]) <- st_buffer(st_union(st_union(st_geometry(faces[faces$id==i,]),st_geometry(tops[tops$id==i,]))),1)
st_geometry(blocs[i,]) <- st_buffer(st_union(st_union(st_geometry(faces[faces$id==i,]),st_geometry(tops[tops$id==i,]))),1)
}
message("Topological issues (3/3)")
for(i in ids){
v <- as.numeric(tops[tops$id == i,var] %>% st_drop_geometry())
tmp <- tops %>% st_drop_geometry()
ids2 <- tmp[tmp[,var] > v & tmp$id != i,"id"]
geom1 <- st_geometry(tops[tops$id == i,])
# plot(geom1)
geom2 <- st_geometry(blocs[blocs$id %in% ids2,])
# plot(geom2)
geom <- st_difference(geom1, st_union(geom2))
if(length(geom) > 0) {
st_geometry(tops[tops$id == i,]) <- geom
} else {
# Supprimer les geometries vides (TODO)
}
}
# 3  - bind & sort faces
# faces2 <- st_difference(f3,st_buffer(st_union(st_geometry(tops)),1))
f <- rbind(faces, f3)
f <- f[order(f$pos, decreasing = TRUE),]
} else {f <- faces}
# Display
#
#
# plot(st_geometry(x), add=add)
# plot(st_geometry(f), col = f$fill, add=T)
# plot(st_geometry(tops), col=fill[1], add=T)
plot(st_geometry(x), add=add)
for(i in tops$id)
{
plot(st_geometry(f[f$id == i,]), col=f$fill, add=T)
plot(st_geometry(tops[tops$id == i,]), col=fill[1], add=T)
}
message("Done")
}
states <- readRDS("us.rds")
basemap <- deform(states)
extrude(basemap, var = "pop2019" , k = 1, col = "red", add = FALSE)
extrude <- function(x, var, k = 1, col = "red", regular = FALSE, add = FALSE) {
tmp <- x[is.na(x[,var]),]
ids <- row.names(tmp)
x[rownames(x) %in% ids,var] <- 0
h <- st_bbox(x)[4]-st_bbox(x)[2]
m <- max(x[,var] %>% st_drop_geometry())
k = k * 0.1 * h / m
x$id <- row.names(x)
x[,"height"] <- x[,var] %>% st_drop_geometry() * k
x[is.na(x[,var]),"height"] <- 0
n1 <- dim(x)[1]
x <- st_cast(x, "POLYGON", warn = FALSE)
n2 <- dim(x)[1]
if(n2 > n1){message("Splitting multi-part polygon into single polygons. The same value is assigned to each splitted polygon.")}
nodes <- st_cast(x,"POINT", warn = FALSE)
# Faces
message("Starting extrusion")
nodes$first <- !duplicated(nodes$id)
nodes$last <- !duplicated(nodes$id, fromLast = TRUE)
dots1 <- nodes[!nodes$last,]
dots2 <- nodes[!nodes$first,]
p1x <- st_coordinates(dots1)[,1]
p1y <- st_coordinates(dots1)[,2]
p2x <- st_coordinates(dots2)[,1]
p2y <- st_coordinates(dots2)[,2]
p3x <- p2x
p3y <- p2y + dots2$height
p4x <- p1x
p4y <- p1y + dots1$height
faces <- dots1
faces$ang <- atan((p2y - p1y) / ( p2x - p1x))*180/pi
faces$pos <- (p1y + p2y)/2
st_geometry(faces) <- st_as_sfc(paste0("POLYGON((",p1x," ",p1y,", ",p2x," ",p2y,", ",p3x," ",p3y,", ",p4x," ",p4y,", ",p1x," ",p1y,"))"))
faces <- faces[order(faces$pos, decreasing = TRUE),]
# Colors
if(length(col) == 1){
if(col == "white"){
fill <- c("white","white","white")
} else {
pal <- colorRampPalette(c("white",col,"black"))(11)
fill <- c(col, pal[3],pal[7])
}
}
if(length(col)==2){
fill <- c(col[1],col[2],col[2])
}
if(length(col)==3){
fill <- col
}
faces$fill <- fill[2]
faces[faces$ang > 0,"fill"] <- fill[3]
# Tops
tops <- x
for (i in 1:dim(tops)[1])
{
st_geometry(tops[i,]) <- st_geometry(tops[i,]) + c(0, as.numeric(x[i,var])[1] * k)
}
tops <- tops[order(tops$height, decreasing = FALSE),]
# faces <- st_difference(faces,st_buffer(st_union(st_geometry(tops)),1))
# plot(st_geometry(faces), col="red")
# Opérations géométriques
# 1 - Faces cleaning
if(regular == FALSE){
message("Topological issues (1/3)")
faces$xpos <- round(st_coordinates(st_centroid(st_geometry(faces)))[,1],0)
faces$dup1 <- as.numeric(duplicated(faces$pos))
faces$dup2 <- as.numeric(duplicated(faces$pos, fromLast = TRUE))
faces$dup3 <- as.numeric(duplicated(faces$xpos))
faces$dup4 <- as.numeric(duplicated(faces$xpos, fromLast = TRUE))
faces$test1 <- faces$dup1 + faces$dup3
faces$test2 <- faces$dup2 + faces$dup4
faces$test3 <- faces$dup1 + faces$dup2 + faces$dup3 + faces$dup4
f1 <- faces[faces$test1 == 2,]
f2 <- faces[faces$test2 == 2,]
f3 <- faces[faces$test3 == 0,]
nb <- dim(f2)[1]
f <- f1
for(i in 1:nb){
if (f1$height[i] == max(f1$heigh[i],f2$heigh[i])){
st_geometry(f[i,]) <- st_difference(st_geometry(f1[i,]),st_geometry(f2[i,]) )
f$id[i] <- f1$id[i]
} else {
st_geometry(f[i,]) <- st_difference(st_geometry(f2[i,]),st_geometry(f1[i,]) )
f$id[i] <- f2$id[i]
}
}
faces <- f
faces <- faces[order(faces$pos, decreasing = TRUE),]
# alltops <- st_buffer(st_union(st_geometry(tops)),1)
# faces <- st_difference(faces,alltops)
# 2 -Tops cleaning
message("Topological issues (2/3)")
blocs <- x
for (i in ids){
#st_geometry(blocs[i,]) <- st_buffer(st_union(st_union(st_geometry(faces[faces$id==i,]),st_geometry(tops[tops$id==i,]))),1)
st_geometry(blocs[i,]) <- st_buffer(st_union(st_union(st_geometry(faces[faces$id==i,]),st_geometry(tops[tops$id==i,]))),1)
}
message("Topological issues (3/3)")
for(i in ids){
v <- as.numeric(tops[tops$id == i,var] %>% st_drop_geometry())
tmp <- tops %>% st_drop_geometry()
ids2 <- tmp[tmp[,var] > v & tmp$id != i,"id"]
geom1 <- st_geometry(tops[tops$id == i,])
# plot(geom1)
geom2 <- st_geometry(blocs[blocs$id %in% ids2,])
# plot(geom2)
geom <- st_difference(geom1, st_union(geom2))
if(length(geom) > 0) {
st_geometry(tops[tops$id == i,]) <- geom
} else {
# Supprimer les geometries vides (TODO)
}
}
# 3  - bind & sort faces
# faces2 <- st_difference(f3,st_buffer(st_union(st_geometry(tops)),1))
f <- rbind(faces, f3)
f <- f[order(f$pos, decreasing = TRUE),]
} else {f <- faces}
# Display
#
#
# plot(st_geometry(x), add=add)
# plot(st_geometry(f), col = f$fill, add=T)
# plot(st_geometry(tops), col=fill[1], add=T)
plot(st_geometry(x), add=add)
for(i in tops$id)
{
plot(st_geometry(f[f$id == i,]), col=f$fill[f$id ==i], add=T)
plot(st_geometry(tops[tops$id == i,]), col=fill[1], add=T)
}
message("Done")
}
states <- readRDS("us.rds")
basemap <- deform(states)
extrude(basemap, var = "pop2019" , k = 1, col = "red", add = FALSE)
states <- readRDS("us.rds")
frame <- deform(getframe(x))
basemap <- deform(states)
plot(st_geometry(frame))
extrude(basemap, "pop2019", k = 1, col = "white", add = TRUE)
world <- readRDS("worldpopgrid.rds")
basemap <- deform(world)
extrude(basemap, "pop2020", k = 1, col = "red", regular = TRUE)
